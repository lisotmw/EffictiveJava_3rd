  当你从集合中取出元素时编译器会为你插入不可见的映射，并且保证这个过程不会失败(再次假设，你所有的代码不会生成或是抑制任何编译器的警告)。
尽管偶然将一枚硬币放入邮票集合的预期可能显得有些牵强，然而问题是真实存在的。例如，很容易想象将一个BigInteger实例放入一个只允许放BigDecimal实例的集合
  如前所述，使用原始类型（不带类型参数的泛型）是合法的，但你决不能使用原始类型，如果你使用原始类型，
那么你就失去了泛型的安全性和表达性收益。考虑到你不应该使用原始类型，那么为什么语言的设计者起初允许泛型存在呢？
是为了兼容性。当泛型被加入进来的时候 Java 差不多进入了它的第二个十年了，因此有大量现存的代码没有使用泛型。
保持所有原始类型代码的合法性并且让它们同使用泛型的新代码混合使用，这种设计曾经饱受争议。然而这必须是合法的，它把类型参数的
实例传入参数设计为原始类型的方法，或是将原始类型参数传入泛型方法。这种设计去支持原始类型并用擦除实现泛型（第28条）的需求被称为迁移兼容性。
  